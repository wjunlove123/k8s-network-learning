---------------------------------------------------------------------------------------------------------------
# This for anlysics the flannel udp mode's datapath:
$ k get nodes -owide  | grep -E "bpf1|bpf3"
bpf1   Ready    control-plane,master   13d   v1.23.4   192.168.2.71   <none>        Ubuntu 20.04.5 LTS   5.15.0-52-generic   docker://20.10.21
bpf3   Ready    <none>                 13d   v1.23.4   192.168.2.73   <none>        Ubuntu 20.04.5 LTS   5.15.0-52-generic   docker://20.10.21

$ k get pods  -owide  | grep -E "bpf1|bpf3"
cilium-native-routing-68qn2   1/1     Running   0          39h   10.244.2.23    bpf3   <none>           <none>
cilium-native-routing-b84xc   1/1     Running   0          39h   10.244.0.169   bpf1   <none>           <none>

$ k exec -it cilium-native-routing-b84xc -- ping -c 1 10.244.2.23

---------------------------------------------------------------------------------------------------------------
Step1: Pod_$(BPF1) ---> BPF1_Node:
---------------------------------------------------------------------------------------------------------------
When do ping at Pod: cilium-native-routing-b84xc, it will trigger the routing quary logical:
$ k exec -ti cilium-native-routing-b84xc -- bash 
bash-5.1# ip -d r s 
unicast default via 10.244.0.144 dev eth0 proto boot scope global mtu 1500   # match this table, the next-hop is 10.244.0.144, the outgoing interface is eth0
unicast 10.244.0.144 dev eth0 proto boot scope link                          # but there is an iterative route quary.when quary the route,it show how to send packet to 10.244.0.144. This is very important. it show the real logical about the Linux Routing Table.

when triger the ping from pod cilium-native-routing-b84xc, we can see the arp table:
$ ip n s 
10.244.0.144 dev eth0 lladdr 26:9e:24:29:2b:1c STALE
$ ip a | grep "26:9e:24:29:2b:1c" -C1
9: lxcd870fde69316@if8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
    link/ether 26:9e:24:29:2b:1c brd ff:ff:ff:ff:ff:ff link-netnsid 1
    inet6 fe80::249e:24ff:fe29:2b1c/64 scope link 

!!!Note:
From the ARP table, we can see that the Dst_MAC is the veth-pair(ROOT NS side), but the GW IP(10.244.0.144) is the {cilium_host}.
$ 5: cilium_host@cilium_net: <BROADCAST,MULTICAST,NOARP,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
    link/ether a6:b1:41:22:b9:55 brd ff:ff:ff:ff:ff:ff
    inet 10.244.0.144/32 scope link cilium_host
       valid_lft forever preferred_lft forever

Why???. How to understand this case?

5: cilium_host@cilium_net: <BROADCAST,MULTICAST,NOARP,UP,LOWER_UP> !!!!----This also show NOARP. What's NOARP?
$ man ip-link | grep -i noarp -C1
    arp on or arp off
      change the NOARP flag on the device.  // From the manual, we can see it's switch for ARP on or off. This case indicate ARP off.
Ok. ARP Off. That means: It will not response the ARP. From the ip neigh tabe, the DST_MAC is not the gw's MAC_Address at same time. 
But we need one dst_mac_address when arp request triggered. 
The cilium use the hardcode method to hijcak the traffic to the veth-pair(ROOT NS side.),So, Replay the veth-pair(ROOT NS side)'s mac address is a good chioce.
Okay, the above is the logical  for Cilium transfer the packet from the pod to the ROOT NS. 
We can make a summary: 1. Flannel use the Bridge Mode   2.Calico use the Prxoy-ARP   3. Cilium use the hardcode method.


---------------------------------------------------------------------------------------------------------------
Step2: ROOT NS handle the packet: S_IP: 10.244.0.104  D_IP: 10.244.2.26
---------------------------------------------------------------------------------------------------------------
When the ROOT NS recv the packet. how to deal? Rougint/FDB/netfilter?. Yes, we are always consider the Routing fitstly.
$ ip -d r s 
unicast default via 192.168.2.1 dev ens160 proto static scope global metric 100 
unicast 10.244.0.0/24 via 10.244.0.144 dev cilium_host proto boot scope global src 10.244.0.144 
unicast 10.244.0.144 dev cilium_host proto boot scope link 
unicast 10.244.1.0/24 via 192.168.2.72 dev ens160 proto boot scope global 
unicast 10.244.2.0/24 via 192.168.2.73 dev ens160 proto boot scope global  // match this table. next-hopï¼š192.168.2.73. Outgoing interface: ens160, scope: global
unicast 169.254.0.0/16 dev ens160 proto boot scope link metric 1000 
unicast 172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown 
unicast 192.168.2.0/24 dev ens160 proto kernel scope link src 192.168.2.71 metric 100 

From the table: it shows that the packet need send to the 192.168.2.73, so should get the 192.168.2.73's mac address, it will trigger iterative route quary to:
unicast 192.168.2.0/24 dev ens160 proto kernel scope link src 192.168.2.71 metric 100 //this table to learn the 192.168.2.73's mac address.
This is the tradditional method to transfer the patcket with direct routing mode which like flanne(host-gw backend) and calico's bgp mode.

But the Cilium have much advanced features. Like bpf_redirect_peer() and bpf_reirect_neigh() helpers function. 
FAQ: So,what's the bpf_redirect_peer() and bpf_reirect_neigh() helpers?
we will use the split workspace to explin the advanced feature about Cilium.












